---
title: "LeetCode 62: Unique Paths - DP 접근법"
published: false
description: "LeetCode 62번 문제 Unique Paths를 동적 프로그래밍(DP)으로 해결하는 방법"
tags: ["알고리즘", "동적프로그래밍", "DP", "LeetCode", "코딩테스트"]
cover_image:
series: "LeetCode 문제 풀이"
---

# Unique Paths 문제 (LeetCode 62번)

이 문제는 전형적인 동적 프로그래밍(DP) 문제입니다.  
DP란 반복적인 계산을 저장해서 효율적으로 문제를 푸는 방식입니다.

처음에는 순열 공식(조합론)을 사용하여 해결해 보았습니다. 하지만 이 방법은 큰 입력값에서 오버플로우가 발생할 수 있어 최적의 방법은 아닙니다.

## 방법 1: 조합론(순열) 접근법

```kotlin
/**
 * 정수의 팩토리얼 값을 계산하는 확장 함수
 * @return 팩토리얼 결과 (Long 타입)
 */
fun Int.factorial(): Long {
    var result = 1L
    for (i in 2..this) {
        result *= i
    }
    return result
}

class Solution {
    /**
     * 시작점에서 끝점까지 도달하는 유니크 경로의 수 계산 (순열 방법)
     * 공식: (m+n-2)! / ((m-1)! * (n-1)!)
     * @param m 그리드의 행 수
     * @param n 그리드의 열 수
     * @return 가능한 경로의 수
     */
    fun uniquePaths(m: Int, n: Int): Int {
        val numerator = (m + n - 2).factorial()
        val denominator = (m - 1).factorial() * (n - 1).factorial()
        return (numerator / denominator).toInt()
    }
}
```

위처럼 팩토리얼로 해결할 수 있지만, 이 문제는 본래 DP(동적 프로그래밍)로 해결하는 것이 더 효율적입니다.

## 방법 2: 동적 프로그래밍(DP) 접근법

```kotlin
class Solution {
    /**
     * 시작점에서 끝점까지 도달하는 유니크 경로의 수 계산 (DP 방법)
     * 각 위치까지 도달할 수 있는 경로의 수는 왼쪽과 위쪽에서 오는 경로의 합
     * @param m 그리드의 행 수
     * @param n 그리드의 열 수
     * @return 가능한 경로의 수
     */
    fun uniquePaths(m: Int, n: Int): Int {
        val dp = IntArray(n) { 1 } // 첫 번째 행은 모두 1로 초기화
        for (i in 1 until m) {
            for (j in 1 until n) {
                dp[j] += dp[j - 1] // 현재 위치 = 위쪽 경로 + 왼쪽 경로
            }
        }
        return dp[n - 1]
    }
}
```

## DP 방식 동작 원리

아래 표는 m=3, n=7인 경우의 각 위치까지 도달할 수 있는 경로의 수입니다:

| (i,j) | 0열 | 1열 | 2열 | 3열 | 4열 | 5열 | 6열 |
| ----- | --- | --- | --- | --- | --- | --- | --- |
| 0행   | 1   | 1   | 1   | 1   | 1   | 1   | 1   |
| 1행   | 1   | 2   | 3   | 4   | 5   | 6   | 7   |
| 2행   | 1   | 3   | 6   | 10  | 15  | 21  | 28  |

### DP의 직관적 이해

DP 방식이 어떻게 작동하는지 구체적인 예시로 이해해 보겠습니다:

1. **위치 (1,2)의 경우:**

   - 위치 (1,2)의 값은 3입니다.
   - 이는 위쪽 위치 (0,2)의 값 1과 왼쪽 위치 (1,1)의 값 2를 더한 결과입니다.
   - 즉, 3 = 1 + 2 입니다.

2. **위치 (2,2)의 경우:**
   - 위치 (2,2)의 값은 6입니다.
   - 이는 위쪽 위치 (1,2)의 값 3과 왼쪽 위치 (2,1)의 값 3을 더한 결과입니다.
   - 즉, 6 = 3 + 3 입니다.

### 왜 이렇게 계산하는가?

위치 (2,2)까지 도달하는 경우의 수가 6개인 이유는:

- 위치 (1,2)까지 도달하는 3가지 경로가 있고, 각각의 경로에서 아래로 한 칸 이동하면 (2,2)에 도달합니다.
- 위치 (2,1)까지 도달하는 3가지 경로가 있고, 각각의 경로에서 오른쪽으로 한 칸 이동하면 (2,2)에 도달합니다.
- 이 두 경로 집합은 서로 겹치지 않으므로, 총 경로 수는 3 + 3 = 6입니다.

이렇게 동적 프로그래밍은 이전에 계산한 결과를 저장하고 재활용하여 중복 계산을 피하고 효율적으로 문제를 해결합니다.
