---
title: "72"
published: false
description: ""
tags: ["알고리즘", "동적프로그래밍", "DP", "LeetCode", "코딩테스트"]
cover_image:
series: "LeetCode 문제 풀이"
---

72. Edit Distance

Input: word1 = "horse", word2 = "ros"
Output: 3

```kotlin
class Solution {
    fun minDistance(word1: String, word2: String): Int {
        val m = word1.length   길이를 설정한다
        val n = word2.length   길이를 설정한다
        val dp = Array(m + 1) { IntArray(n + 1) }  2차원배열을 만들어준다

        // 초기화: word1이 빈 문자열인 경우, word2까지 삽입한경우의 결과값이다
        for (i in 0..m) {
            dp[i][0] = i
        }

        // 초기화: word2가 빈 문자열인 경우, word1에서 삭제만 한 결과값이다
        for (j in 0..n) {
            dp[0][j] = j
        }
        여기까지는 할만하다 이해할수있다


        // DP 테이블 채우기
        for (i in 1..m 5) {              Input: word1 = "horse", word2 = "ros"
            for (j in 1..n  3) {
                if (word1[i - 1] == word2[j - 1]) { //값이 같을경우 아래의 삭제, 삽입, 교체등 필요없다
                    dp[i][j] = dp[i - 1][j - 1]   // 0, 0 이 같은건 dp 에서 문자 처리는 1부터 시작하기때문에 저게 맞다
                } else {
                    // 처음에 계산을 00 대에서 시작하기때문에 dp [i][j]에 계산값을 넣어주는거다
                    // 가장 작은값을 넣어주는 이유는 i와 j는 그 행동을 취했다는 값을 남기는것이다 3개의 방법을 사용했는데 이게 숫자가 가장 낮더라 하는 방법을 취했다
                    // 그리고 그값이 i와 j에 적용된다 이렇게 되면 1, 1은 적용되었고 또다시 계산할때 사용되어 누적된다

                    i=1, j=2
                    dp[i][j] = 1 + minOf(
                        dp[i - 1][j],    // 삭제: word1에서 현재 문자를 삭제
                        dp[i][j - 1],    // 삽입: word1에 word2의 현재 문자를 삽입
                        dp[i - 1][j - 1] // 교체: word1의 현재 문자를 word2의 현재 문자로 교체
                    )
                }
            }
        }

        return dp[m][n]
    }
}
```

## 3가지 연산이 왜 필요한지 자세한 설명

Edit Distance는 문자열을 변환하는 3가지 기본 연산을 사용합니다:

### 1. 삭제 (Delete) - `dp[i-1][j]`

- **의미**: word1에서 현재 문자를 삭제하는 경우
- **예시**: "horse" → "orse" (h 삭제)
- **DP 관점**: word1의 i-1번째까지와 word2의 j번째까지를 맞추는 비용에 +1

### 2. 삽입 (Insert) - `dp[i][j-1]`

- **의미**: word1에 word2의 현재 문자를 삽입하는 경우
- **예시**: "ros" → "rose" (e 삽입)
- **DP 관점**: word1의 i번째까지와 word2의 j-1번째까지를 맞추는 비용에 +1

### 3. 교체 (Replace) - `dp[i-1][j-1]`

- **의미**: word1의 현재 문자를 word2의 현재 문자로 교체하는 경우
- **예시**: "horse" → "rorse" (h를 r로 교체)
- **DP 관점**: word1의 i-1번째까지와 word2의 j-1번째까지를 맞추는 비용에 +1

## 구체적인 예시로 이해하기

`word1 = "horse"`, `word2 = "ros"`일 때, dp[2][2] (word1의 "ho"와 word2의 "ro"를 맞추는 경우):

```
word1[1] = 'o', word2[1] = 'o'
→ 같으므로 dp[2][2] = dp[1][1] = 1
```

만약 다르다면:

```
word1[1] = 'o', word2[1] = 's'라고 가정하면:

1. 삭제: dp[1][2] + 1 = "h"와 "ro"를 맞추는 비용 + 'o' 삭제
2. 삽입: dp[2][1] + 1 = "ho"와 "r"를 맞추는 비용 + 's' 삽입
3. 교체: dp[1][1] + 1 = "h"와 "r"를 맞추는 비용 + 'o'를 's'로 교체

이 중 최솟값을 선택!
```

## 왜 이 3가지만 고려하면 될까?

문자열 편집에서 가능한 모든 연산을 이 3가지로 표현할 수 있기 때문입니다:

- **문자가 다를 때**: 삭제하거나, 삽입하거나, 교체하는 것이 유일한 선택
- **각 연산의 최적해**: 이전 상태들의 최적해를 활용 (동적 계획법의 핵심)
- **최솟값 선택**: 3가지 중 가장 적은 비용이 드는 방법을 선택
